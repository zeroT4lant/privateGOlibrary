package main

import (
	"fmt"
	"runtime"
	"time"
)

// Горутина - легковесные потоки(Размер стэка обычно 2КБ)
// могут выполняться как конкурентно, так и параллельно
// горутинами управляет планировщик Го, в отличие от потоков, которыми управляет OS
// функция main - тоже горутина
// состояние горутин - создание, запущена/заблокированна, выход

// В ГОРУТИНЕ ПИШЕШЬ ТО - ЧТО ХОЧЕШЬ ВЫПОЛНИТЬ АСИНХРОННО
func main() {
	//Цель планировщика ГО - быстрее закончить выполнение программы
	go showNumbers(100)

	//количество возможных горутин на этом устройстве
	fmt.Println(runtime.NumCPU())

	//указываем сколько горутин могут выполняться
	//runtime.GOMAXPROCS(1) //если поставить 1, то код будет выполняться конкурентно

	//помогает переключится на другую горутину
	//runtime.Gosched()

	//в таком случае планировщик переключится на выполнение другого потока, так как основной спит
	time.Sleep(time.Second)

	//функции с defer выполняются всегда в самом конце
	//складываются в defer stack и выполняются в порядке - обратном добавлению при выходе из функции
	//вызовется сначала 2, потом 1
	defer fmt.Println("1")
	defer fmt.Println("2")

	//PANICS
	makePanic()
}

func showNumbers(num int) {
	for i := 0; i < num; i++ {
		fmt.Println(i)
	}
}

func sumWithDef(x, y int) (sum int) {
	//2) Потом сумма умножится
	defer func() {
		sum *= 2
	}()

	//1) Сначала числа сложатся
	sum = x + y
	return
}

func deferValues() {
	//пишет числа в обратном порядке
	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	//неправильно
	//ждёт прохождения итераций, потом 10 раз выводит число "10"
	for i := 0; i < 10; i++ {
		defer func() {
			fmt.Println(i)
		}()
	}

	//правильно
	for i := 0; i < 10; i++ {
		k := i
		defer func() {
			fmt.Println(k)
		}()
	}

	//правильно
	//анонимная функция, принимает параметр k int, в конце - в круглых скобках мы сразу её вызываем, и передаём в аргумент значение i, для исполнения
	//а (i) в конце - это сразу вызов функции, который будет передан вместо K
	for i := 0; i < 10; i++ {
		defer func(k int) {
			fmt.Println(k)
		}(i)
	}
}

func makePanic() {
	//recover лучше выполнять в deffered функции
	defer func() {
		//если паника случается, recover возвращает значение из паники
		panicValue := recover()
		//и дальше выводим на экран
		fmt.Println(panicValue)
	}()

	panic("Some panic")
	//после паники мы не сможем добраться до него, программа завершится
	fmt.Println("Недосягаемый код")
}
