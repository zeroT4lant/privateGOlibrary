package main

import (
	"fmt"
	"sync"
)

//а также структуры или массивы, содержащие только эти типы

//Обход мапы сделали рандомным, через функцию fastRand
//Чтобы не завязываться на порядке следования ключей.

// В ключе может иметь любой сравниваемый тип
// Числовые int,float,uint,complex
// Строковые типы String
// Булев тип bool
// Срезы(могут быть равны если указывают на один и тот же массив данных, либо длина равна) []Int,[]float32,[]string
// Карты(другие мапы)
// Указатели *int,*float32,*string
// Структуры

// Несравниваемые типы — срезы, мапы, функции.
// Слайсы Два слайса могут быть равны друг другу только если они указывают на один и тот же массив данных.
// Функции
// Каналы
// Интерфейсы

//Устройство МАПЫ
//-------------------------
//Мапа разбивается на бакеты для более эфективного поиска
//Хэш-функция используется для равномерного распределения ключей по бакетам
//При переполнении бакета происходит рост мапы
//Эвакуация данных происходит при заполнении мапы
//Порядок обхода мапы является случайным.

//Эвакуация - дописать про эвакуацию!!!!
//Когда количество элементов в мапе достигает определённого порога, то мапа растёт
// То есть создаётся новая - более большая мапа и все элементы из старой копируются в новую.
// Рост мапы происходит асинхронно - значит, что все данные переходят постепенно.

//Коллизии
//Разрешаются с помощью бакетов
//Каждый бакет содержит до 8 элементов(8 пар ключ-значение)
//Если все ячейки в бакете забиты, то мапа растёт и эвакируется.
//При помощи хэш функции ключи равномерно распределяются по бакетам. Это позволяет уменьшить количество коллизий.
//И обеспечить быстрый доступ к данным.
//Разрешить проблему с коллизиями можно с помощью двух методов: открытой адресации и метода цепочек
//Открытая адрессация - помещаем ключ в свободную ячейку, следующую за текущей или пока не найдёт место.Поиск также по тому же ключу и продолжения поиска до следующего пустого места.
//Метод цепочек - это реализация двусвязного списка, при одинаковом ключе образуем цепочку элементов с одинаковыми хэшами

//sync.Map обычно близка по скорости к обычной мапе с sync.RWMutex,
//но может быть лучше в случае чтения. Когда происходит чтение и обновление, sync.Map будет иметь элементы и в чтении, и в “грязном” состоянии.
//при работе с syncMap есть три метода Load Store Delete
//sync.Map состоит из двух мап - одной для чтения и одной для новых элементов.
//sync.Map следует использовать, когда большинство операций с мапой - это чтение, и когда ключи мапы меняются динамически.

//Бакеты в структуре
//count - количество пар "ключ-значение"
//B - количество бакетов выраженное через log2
//buckets - указатель в структуре на массив бакетов

//В nil мапу нельзя записывать ключ/значения - var m map[string]string

//-------------------------

func main() {
	// 2) Map
	m1 := map[string]int{"a": 1, "b": 2, "c": 3}

	for a, b := range m1 {
		fmt.Println(a, b)
	}

	//Конкурентная запись в Мапу
	//Стандартная мапа - не потокобезопасный тип.
	//При конкурентной записи будет происходить Data Race
	//Во избежание этого используем пакет syncMap или реализацию с RWMutex
	var wg sync.WaitGroup
	var mu sync.Mutex

	m := make(map[int]int)
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func(k int) {
			defer wg.Done()
			mu.Lock()
			m[k] = k * 2
			mu.Unlock()
		}(i)
	}
	wg.Wait()
	fmt.Println(m)

	//Адрес нельзя взять у Мапы, потому что данные могу эвакуироваться

	//ПОДСЧЁТ УНИКАЛЬНЫХ ЗНАЧЕНИЙ
	sliceForMapString := []string{"a", "b", "a", "c", "d", "d", "a"}
	mapStrings := make(map[string]int, 5)
	for _, v := range sliceForMapString {
		//Для каждого найденного ключа добавляем +1 найденную строку
		mapStrings[v]++
		//или
		// if _, ok := mapStrings[v]; !ok {
		// 	mapStrings[v] = 1
		// } else {
		// 	mapStrings[v]++
		// }
	}

	fmt.Println(mapStrings)
}
