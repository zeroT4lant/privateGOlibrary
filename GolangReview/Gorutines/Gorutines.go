package main

import (
	"context"
	"fmt"
	"time"
)

// Горутина - функция, которая может выполняться параллельно с другими функциями.
// Весит 2кб
// Лёгкие и проще переключаются в отличии от потоков
// Управляется планировщиком Go
// Общается с другими горутинами через каналы, которые обеспечивают синхронизацию и безопасность данных.
// GOMAXPROCS - это параметр, который определяет, сколько ядер ЦП используется для одновременного выполнения горутин.
// Остановить горутину можно с помощью контекста, канала или таймаута.
func main() {
	//for i := 0; i < 5; i++ {
	//	go func(int k) {
	//		fmt.Println(k)
	//	}(i)
	//}

	// создаем контекст с отменой
	ctx, cancel := context.WithCancel(context.Background())
	// запускаем горутину с этим контекстом
	go worker(ctx)
	// ждем 3 секунды
	time.Sleep(3 * time.Second)
	// отменяем контекст
	cancel()
	// ждем еще 2 секунды
	time.Sleep(2 * time.Second)

	// создаем канал для передачи сигнала остановки
	stop := make(chan bool)
	// запускаем горутину с этим каналом
	go worker2(stop)
	// ждем 3 секунды
	time.Sleep(3 * time.Second)
	// отправляем сигнал остановки в канал
	stop <- true
	// ждем еще 2 секунды
	time.Sleep(2 * time.Second)
}

func worker(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			// контекст отменен, выходим из горутины
			fmt.Println("worker stopped")
			return
		default:
			// продолжаем работать
			fmt.Println("worker working")
			time.Sleep(time.Second)
		}
	}
}

func worker2(stop chan bool) {
	for {
		select {
		case <-stop:
			// получили сигнал остановки, выходим из горутины
			fmt.Println("worker stopped")
			return
		default:
			// продолжаем работать
			fmt.Println("worker working")
			time.Sleep(time.Second)
		}
	}
}

// **кооперативная** — передачей управления процессы занимаются самостоятельно;

// **вытесняющая** — планировщик дает отработать процессам равное время, после чего переключает контекст.

// В Go планировщик - асинхронно вытесняющий с кооперативными элементами

// Может выполняться конкурентно и параллельно (рис. 1)
// Горутинами управляет планировщик го, в отличие от потоков, котрыми управляет OS
// Программист не создает треды сам, работа с тредами происходит под капотом,
// нам доступны только горутины

// _Кооперативная многозадачность_ предполагает, что контекст переключается в тот момент, когда текущая активная задача явно объявляет о том, что она готова отдать ресурс другой задаче.

// _Вытесняющая многозадачность_ — это вид многозадачности, при котором существует некий компонент, который управляет переключением контекста и может принудительно ставить одни задачи на паузу и продолжать выполнение других. Обычно такой компонент и называется планировщиком.

////Планировщик Go использует алгоритм work stealing для балансировки нагрузки между логическими процессорами

//Позволяет запустить произвольное количество горутин на произвольном количестве потоков.

//Планировщик мультиплексирует горутины на потоки ОС

//В ГО - асинхронно вытесняющий планировщик, с кооперативными элементами

// Планировщик в Golang - это механизм, который отвечает за распределение и выполнение горутин (G)

// на логических процессорах (P),

// которые в свою очередь работают на физических потоках (M) операционной системы.

// G - Горутины - легковесные потоки

// P - (процессы/контекст планирования) Логический процессор представляет собой ресурс, необходимый для выполнения горутин.

// M - Физический поток (операционной системы)

//Основные типы многозадачности что используются в большинстве ОС это "вытесняющая" (все ресурсы делятся между всеми программами одинаково, всем выделяется одинаковое время выполнения)

//и "кооперативная" (программы выполняются столько, сколько им нужно, и сами уступают друг-другу место).

// Вытесняющий планировщик - это такой планировщик, который может прервать выполнение текущей задачи в любой момент и передать управление другой задаче, если он посчитает это необходимым.

// Кооперативный планировщик - это такой планировщик, который не может прервать выполнение текущей задачи, пока она сама не отдаст управление.
